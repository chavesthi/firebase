
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // User documents
    match /users/{userId} {
      allow create: if request.auth != null; // Allow any authenticated user to create their profile initially
      allow read: if true; // Allow anyone to read user profiles (e.g., for names in chat, partner info)
      allow update: if request.auth != null && request.auth.uid == userId; // Only user can update their own profile
      allow delete: if request.auth != null && request.auth.uid == userId; // Only user can delete their own profile

      // Partner specific subcollections
      match /events/{eventId} {
        allow read: if true; // Events can be read publicly
        allow create, update, delete: if request.auth != null && request.auth.uid == userId; // Only partner can manage their events

        match /checkIns/{checkInId} {
            allow read, create: if request.auth != null; // Authenticated users (partners or users) can create/read check-ins
            // Add specific rules for update/delete if needed, e.g., only partner can delete a check-in
        }
      }
      
      // User specific subcollections
       match /checkedInEvents/{eventId} {
        allow read, create, update: if request.auth != null && request.auth.uid == userId; // User manages their check-ins
      }
      match /coupons/{couponId} {
        allow read, create, update, delete: if request.auth != null && request.auth.uid == userId; // User manages their coupons
      }
    }

    // Event ratings
    match /eventRatings/{ratingId} {
      allow create: if request.auth != null; // Authenticated user can create a rating
      allow read: if true; // Ratings can be read publicly (e.g., average on event display)
      // Allow update/delete only by the user who created it
      allow update, delete: if request.auth != null && resource.data.userId == request.auth.uid;
    }

    // Purchased tickets
    match /purchasedTickets/{ticketId} {
        allow create: if request.auth != null && request.resource.data.userId == request.auth.uid; // User can purchase their own ticket
        allow read: if request.auth != null && 
                      (request.auth.uid == resource.data.userId || request.auth.uid == resource.data.partnerId); // User can read their tickets, partner can read tickets for their events
        allow update: if request.auth != null && request.auth.uid == resource.data.partnerId; // Only partner can update ticket status (e.g., validate)
        // Delete might be restricted or allowed for admins/partners
    }

    // Chat Rooms
    match /chatRooms/{roomId} {
      allow read, write: if request.auth != null; // Allow authenticated users to read/write in chat rooms (e.g. create if not exists implicitly)
      
      match /messages/{messageId} {
        allow read: if request.auth != null && exists(/databases/$(database)/documents/chatRooms/$(roomId));
        allow create: if request.auth != null && request.resource.data.userId == request.auth.uid;
        // Users can only delete their own messages
        allow delete: if request.auth != null && resource.data.userId == request.auth.uid;
      }
    }


    // Stripe Extension Collections (adjust based on extension's actual security rule recommendations)
    // Typically, the extension's functions handle writes, users might read their own customer/subscription data.
    match /customers/{uid} {
      allow read, write: if request.auth != null && request.auth.uid == uid;
      
      match /checkout_sessions/{id} {
        allow read, write: if request.auth != null && request.auth.uid == uid;
      }
      match /subscriptions/{id} {
        allow read, write: if request.auth != null && request.auth.uid == uid;
      }
      match /payments/{id} {
        allow read, write: if request.auth != null && request.auth.uid == uid;
      }
      match /portals/{id} {
        allow read, write: if request.auth != null && request.auth.uid == uid;
      }
    }

    // Fallback for any other collections - deny by default
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
