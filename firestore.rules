
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Users Collection
    match /users/{userId} {
      allow create: if request.auth != null; // Allow new user creation (signup)
      allow read: if request.auth != null; // Authenticated users can read any user profile (for map, etc.)
                           // Or be more restrictive: if request.auth != null && request.auth.uid == userId; (only own profile)
                           // Or: if request.auth != null && (request.auth.uid == userId || resource.data.role == 'partner'); (own or if it's a partner profile)
      allow update: if request.auth != null && request.auth.uid == userId; // Users can only update their own profile
      allow delete: if request.auth != null && request.auth.uid == userId; // Users can only delete their own account

      // Subcollection: Events (for partners)
      match /events/{eventId} {
        allow read: if true; // Publicly readable events if visibility is true (checked in app logic)
        allow create, update, delete: if request.auth != null && request.auth.uid == userId && get(/databases/$(database)/documents/users/$(userId)).data.role == 'partner';

        // Sub-subcollection: CheckIns for an Event
        match /checkIns/{checkInUserId} {
          allow read: if request.auth != null && request.auth.uid == userId; // Partner can read check-ins for their event
          allow create: if request.auth != null && request.auth.uid == checkInUserId; // User checking in must be themselves
          // No update/delete for check-ins usually
        }
      }

      // Subcollection: User's Checked-In Events (for users to track where they checked in)
      match /checkedInEvents/{eventId} {
         allow read, create, update: if request.auth != null && request.auth.uid == userId; // User manages their own list
         // No delete for now, could be added if users can "undo" a check-in display
      }
      
      // Subcollection: User's Coupons
      match /coupons/{couponId} {
        allow read, create, update, delete: if request.auth != null && request.auth.uid == userId; // User manages their own coupons
      }
    }

    // Event Ratings Collection (assuming a top-level collection for ratings for easier querying by partner)
    // Document ID could be: eventId_userId
    match /eventRatings/{ratingId} {
      allow create: if request.auth != null && request.resource.data.userId == request.auth.uid; // User creates their own rating
      allow read: if true; // Allow anyone to read ratings (e.g., for display on event page)
      allow update, delete: if request.auth != null && request.resource.data.userId == request.auth.uid; // User can update/delete their own rating
                                // Or: if request.auth != null && (request.resource.data.userId == request.auth.uid || get(/databases/$(database)/documents/users/$(request.resource.data.partnerId)).data.role == 'partner'); // Partner can also manage ratings
    }

    // Purchased Tickets Collection (top-level)
    match /purchasedTickets/{ticketId} {
        allow create: if request.auth != null && request.resource.data.userId == request.auth.uid; // User can purchase their own ticket
        allow read: if request.auth != null && 
                        (request.auth.uid == resource.data.userId || // User can read their own ticket
                         request.auth.uid == resource.data.partnerId); // Partner can read tickets for their events
        allow update: if request.auth != null && request.auth.uid == resource.data.partnerId; // Partner can update ticket status (e.g., validate)
        // No delete for tickets typically, they become part of record
    }
    
    // Chat Rooms
    match /chatRooms/{roomId} {
      allow read: if request.auth != null; // Any authenticated user can read room details (e.g. to list rooms - not implemented yet)
      
      match /messages/{messageId} {
        allow read: if request.auth != null; // Any authenticated user can read messages in any room
        allow create: if request.auth != null && 
                         request.resource.data.userId == request.auth.uid &&
                         request.resource.data.text != null &&
                         request.resource.data.userName != null &&
                         request.resource.data.timestamp == request.time;
        // No updates or deletes for messages for now
      }
    }


    // Stripe Extension Collections (adjust based on your specific extension version and needs)
    // Default rules provided by the extension are usually sufficient, but ensure they align.
    // Example for customers creating checkout sessions and portals:
    match /customers/{uid} {
      allow read, write: if request.auth != null && request.auth.uid == uid;

      match /checkout_sessions/{id} {
        allow read, write: if request.auth != null && request.auth.uid == uid;
      }
      match /subscriptions/{id} {
        allow read: if request.auth != null && request.auth.uid == uid;
      }
      match /payments/{id} {
        allow read: if request.auth != null && request.auth.uid == uid;
      }
       match /portals/{id} {
        allow read, write: if request.auth != null && request.auth.uid == uid;
      }
    }
  }
}
